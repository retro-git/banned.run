"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksr_archive_lb"] = self["webpackChunksr_archive_lb"] || []).push([["vendors-node_modules_ably_vcdiff-decoder_lib_vcdiff_decoder_js"],{

/***/ "./node_modules/@ably/vcdiff-decoder/lib/address_caches/near.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/address_caches/near.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\nfunction NearCache(size) {\n  this.size = size;\n  this.near = new Array(this.size).fill(0);\n  this.nextSlot = 0;\n}\n\nNearCache.prototype.update = function(address) {\n  if (this.near.length > 0) {\n    this.near[this.nextSlot] = address;\n    this.nextSlot = (this.nextSlot + 1) % this.near.length;\n  }\n};\n\nNearCache.prototype.get = function(m, offset) {\n  let address = this.near[m] + offset;\n  return address;\n};\n\nmodule.exports = NearCache;\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/address_caches/near.js?");

/***/ }),

/***/ "./node_modules/@ably/vcdiff-decoder/lib/address_caches/same.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/address_caches/same.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\nfunction SameCache(size) {\n  this.size = size;\n  this.same = new Array(this.size * 256).fill(0);\n}\n\nSameCache.prototype.update = function(address) {\n  if (this.same.length > 0) {\n    this.same[address % (this.size * 256)] = address;\n  }\n};\n\nSameCache.prototype.get = function(m, offset) {\n  let address = this.same[m * 256 + offset];\n  return address;\n};\n\nmodule.exports = SameCache;\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/address_caches/same.js?");

/***/ }),

/***/ "./node_modules/@ably/vcdiff-decoder/lib/deserialize/delta.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/deserialize/delta.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst errors = __webpack_require__(/*! ../errors */ \"./node_modules/@ably/vcdiff-decoder/lib/errors.js\");\nconst deserializeInteger = __webpack_require__(/*! ./integer */ \"./node_modules/@ably/vcdiff-decoder/lib/deserialize/integer.js\");\nconst tokenizeInstructions = __webpack_require__(/*! ../tokenize_instructions */ \"./node_modules/@ably/vcdiff-decoder/lib/tokenize_instructions.js\");\n\nfunction delta(delta, position) {\n\n  let targetWindowLength, dataLength, instructionsLength, addressesLength;\n\n  // parentheses are needed for assignment destructuring\n  ({ value: targetWindowLength, position } = deserializeInteger(delta, position));\n\n  // Delta_Indicator byte\n  if (delta[position] !== 0) {\n    throw new errors.NotImplemented(\n      'VCD_DECOMPRESS is not supported, Delta_Indicator must be zero at byte ' + position + ' and not ' + delta[position]\n    );\n  }\n  position++;\n\n  ({ value: dataLength, position } = deserializeInteger(delta, position));\n  ({ value: instructionsLength, position } = deserializeInteger(delta, position));\n  ({ value: addressesLength, position } = deserializeInteger(delta, position));\n\n  let dataNextPosition = position + dataLength;\n  let data = delta.slice(position, dataNextPosition);\n\n  let instructionsNextPosition = dataNextPosition + instructionsLength;\n  let instructions = delta.slice(dataNextPosition, instructionsNextPosition);\n  let deserializedInstructions = tokenizeInstructions(instructions);\n\n  let addressesNextPosition = instructionsNextPosition + addressesLength;\n  let addresses = delta.slice(instructionsNextPosition, addressesNextPosition);\n\n  position = addressesNextPosition;\n\n  let window = {\n    targetWindowLength,\n    position,\n    data,\n    instructions: deserializedInstructions,\n    addresses\n  };\n\n  return window;\n}\n\nmodule.exports = delta;\n\n\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/deserialize/delta.js?");

/***/ }),

/***/ "./node_modules/@ably/vcdiff-decoder/lib/deserialize/integer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/deserialize/integer.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Converts RFC 3284 definition of integer in buffer to decimal\n * Also returns the index of the byte after the integer\n * @param buffer {Uint8Array}\n * @param position {Number}\n * @returns {{position: {Number}, value: {Number}}}\n */\nfunction integer(buffer, position) {\n  const result = { position, value: 0 };\n\n  do {\n    /* Shift the existing value left for 7 bits (base127 conversion)\n       and merge it with the next value without its highest bit */\n    result.value = (result.value << 7) | (buffer[result.position] & 127);\n\n    /* Avoid Number overflows */\n    if (result.value < 0) {\n      throw new Error('RFC 3284 Integer conversion: Buffer overflow');\n    }\n  } while (buffer[result.position++] & 128);\n\n  return result;\n}\n\nmodule.exports = integer;\n\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/deserialize/integer.js?");

/***/ }),

/***/ "./node_modules/@ably/vcdiff-decoder/lib/errors.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/errors.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n/**\n * Takes in array of names of errors and returns an object mapping those names to error functions that take in one parameter that is used as the message for the error\n * @param names {[]}\n * @returns {{name1: function(message),...}}\n * @constructor\n */\nfunction CustomErrors(names) {\n  let errors = {};\n  names.forEach(name => {\n    let CustomError = function CustomError(message) {\n      var temp = Error.apply(this, arguments);\n      temp.name = this.name = name;\n      this.stack = temp.stack;\n      this.message = temp.message;\n      this.name = name;\n      this.message = message;\n    };\n    CustomError.prototype = Object.create(Error.prototype, {\n      constructor: {\n        value: CustomError,\n        writable: true,\n        configurable: true\n      }\n    });\n    errors[name] = CustomError;\n  });\n  return errors;\n}\n\nmodule.exports = CustomErrors(['NotImplemented', 'InvalidDelta']);\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/errors.js?");

/***/ }),

/***/ "./node_modules/@ably/vcdiff-decoder/lib/instructions.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/instructions.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst deserializeInteger = __webpack_require__(/*! ./deserialize/integer */ \"./node_modules/@ably/vcdiff-decoder/lib/deserialize/integer.js\");\nconst TypedArray = __webpack_require__(/*! ./typed_array_util */ \"./node_modules/@ably/vcdiff-decoder/lib/typed_array_util.js\");\n\nfunction ADD(size) {\n  this.size = size;\n}\nfunction COPY(size, mode) {\n  this.size = size;\n  this.mode = mode;\n}\nfunction RUN(size) {\n  this.size = size;\n}\n\nADD.prototype.name = 'ADD';\nCOPY.prototype.name = 'COPY';\nRUN.prototype.name = 'RUN';\n\nADD.prototype.execute = function(delta) {\n  for (let i = 0; i < this.size; i++) {\n    delta.U.set(delta.UTargetPosition + i, delta.data[delta.dataPosition + i]);\n  }\n  delta.dataPosition += this.size;\n  delta.UTargetPosition += this.size;\n};\n\nCOPY.prototype.execute = function(delta) {\n  let address, m, next, method;\n\n  if (this.mode === 0) {\n    address = delta.getNextAddressInteger();\n  }\n  else if (this.mode === 1) {\n    next = delta.getNextAddressInteger();\n    address = delta.UTargetPosition - next;\n  }\n  else if ((m = this.mode - 2) >= 0 && (m < delta.nearCache.size)) {\n    next = delta.getNextAddressInteger();\n    address = delta.nearCache.get(m, next);\n    method = 'near';\n  }\n  // same cache\n  else {\n    m = this.mode - (2 + delta.nearCache.size);\n    next = delta.getNextAddressByte();\n    address = delta.sameCache.get(m, next);\n    method = 'same';\n  }\n\n  delta.nearCache.update(address);\n  delta.sameCache.update(address);\n\n  for (let i = 0; i < this.size; i++) {\n    delta.U.set(delta.UTargetPosition + i, delta.U.get(address + i));\n  }\n\n  delta.UTargetPosition += this.size;\n};\n\nRUN.prototype.execute = function(delta) {\n  for (let i = 0; i < this.size; i++) {\n    // repeat single byte\n    delta.U.set(delta.UTargetPosition + i, delta.data[delta.dataPosition]);\n  }\n  // increment to next byte\n  delta.dataPosition++;\n  delta.UTargetPosition += this.size;\n};\n\nlet instructions = {\n  ADD,\n  COPY,\n  RUN\n};\n\nmodule.exports = instructions;\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/instructions.js?");

/***/ }),

/***/ "./node_modules/@ably/vcdiff-decoder/lib/tokenize_instructions.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/tokenize_instructions.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst instructions = __webpack_require__(/*! ./instructions */ \"./node_modules/@ably/vcdiff-decoder/lib/instructions.js\");\nconst deserializeInteger = __webpack_require__(/*! ./deserialize/integer */ \"./node_modules/@ably/vcdiff-decoder/lib/deserialize/integer.js\");\n\nfunction tokenizeInstructions(instructionsBuffer) {\n  let deserializedInstructions = [];\n\n  let instructionsPosition = 0;\n\n  while (instructionsPosition < instructionsBuffer.length) {\n    let index = instructionsBuffer[instructionsPosition++];\n\n    let addSize, copySize, size;\n\n    if (index === 0) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.RUN(size));\n    }\n    else if (index === 1) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.ADD(size));\n    }\n    else if (index < 19) {\n      deserializedInstructions.push(new instructions.ADD(index - 1));\n    }\n    else if (index === 19) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.COPY(size, 0));\n    }\n    else if (index < 35) {\n      deserializedInstructions.push(new instructions.COPY(index - 16, 0));\n    }\n    else if (index === 35) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.COPY(size, 1));\n    }\n    else if (index < 51) {\n      deserializedInstructions.push(new instructions.COPY(index - 32, 1));\n    }\n    else if (index === 51) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.COPY(size, 2));\n    }\n    else if (index < 67) {\n      deserializedInstructions.push(new instructions.COPY(index - 48, 2));\n    }\n    else if (index === 67) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.COPY(size, 3));\n    }\n    else if (index < 83) {\n      deserializedInstructions.push(new instructions.COPY(index - 64, 3));\n    }\n    else if (index === 83) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.COPY(size, 4));\n    }\n    else if (index < 99) {\n      deserializedInstructions.push(new instructions.COPY(index - 80, 4));\n    }\n    else if (index === 99) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.COPY(size, 5));\n    }\n    else if (index < 115) {\n      deserializedInstructions.push(new instructions.COPY(index - 96, 5));\n    }\n    else if (index === 115) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.COPY(size, 6));\n    }\n    else if (index < 131) {\n      deserializedInstructions.push(new instructions.COPY(index - 112, 6));\n    }\n    else if (index === 131) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.COPY(size, 7));\n    }\n    else if (index < 147) {\n      deserializedInstructions.push(new instructions.COPY(index - 128, 7));\n    }\n    else if (index === 147) {\n      ({ value: size, position: instructionsPosition } = deserializeInteger(instructionsBuffer, instructionsPosition));\n      deserializedInstructions.push(new instructions.COPY(size, 8));\n    }\n    else if (index < 163) {\n      deserializedInstructions.push(new instructions.COPY(index - 144, 8));\n    }\n    else if (index < 175) {\n      ({addSize, copySize} = ADD_COPY(index, 163));\n\n      deserializedInstructions.push(new instructions.ADD(addSize));\n      deserializedInstructions.push(new instructions.COPY(copySize, 0));\n    }\n    else if (index < 187) {\n      ({addSize, copySize} = ADD_COPY(index, 175));\n\n      deserializedInstructions.push(new instructions.ADD(addSize));\n      deserializedInstructions.push(new instructions.COPY(copySize, 1));\n    }\n    else if (index < 199) {\n      ({addSize, copySize} = ADD_COPY(index, 187));\n\n      deserializedInstructions.push(new instructions.ADD(addSize));\n      deserializedInstructions.push(new instructions.COPY(copySize, 2));\n    }\n    else if (index < 211) {\n      ({addSize, copySize} = ADD_COPY(index, 199));\n\n      deserializedInstructions.push(new instructions.ADD(addSize));\n      deserializedInstructions.push(new instructions.COPY(copySize, 3));\n    }\n    else if (index < 223) {\n      ({addSize, copySize} = ADD_COPY(index, 211));\n\n      deserializedInstructions.push(new instructions.ADD(addSize));\n      deserializedInstructions.push(new instructions.COPY(copySize, 4));\n    }\n    else if (index < 235) {\n      ({addSize, copySize} = ADD_COPY(index, 223));\n\n      deserializedInstructions.push(new instructions.ADD(addSize));\n      deserializedInstructions.push(new instructions.COPY(copySize, 5));\n    }\n    else if (index < 239) {\n      deserializedInstructions.push(new instructions.ADD(index - 235 + 1));\n      deserializedInstructions.push(new instructions.COPY(4, 6));\n    }\n    else if (index < 243) {\n      deserializedInstructions.push(new instructions.ADD(index - 239 + 1));\n      deserializedInstructions.push(new instructions.COPY(4, 7));\n    }\n    else if (index < 247) {\n      deserializedInstructions.push(new instructions.ADD(index - 243 + 1));\n      deserializedInstructions.push(new instructions.COPY(4, 8));\n    }\n    else if (index < 256) {\n      deserializedInstructions.push(new instructions.COPY(4, index - 247));\n      deserializedInstructions.push(new instructions.ADD(1));\n    }\n    else {\n      throw new Error('Should not get here');\n    }\n  }\n\n  return deserializedInstructions;\n}\n\nfunction ADD_COPY(index, baseIndex) {\n  let zeroBased = index - baseIndex;\n\n  // 0,1,2 -> 0   3,4,5 -> 1   etc.\n  let addSizeIndex = Math.floor(zeroBased / 3);\n  // offset so size starts at 1\n  let addSize = addSizeIndex + 1;\n\n  // rotate through 0, 1, and 2\n  let copySizeIndex = zeroBased % 3;\n  // offset so size starts at 4\n  let copySize = copySizeIndex + 4;\n\n  return {addSize, copySize};\n}\n\nmodule.exports = tokenizeInstructions;\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/tokenize_instructions.js?");

/***/ }),

/***/ "./node_modules/@ably/vcdiff-decoder/lib/typed_array_util.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/typed_array_util.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("\n\nfunction uint8ArrayToString(uintArray) {\n  let encodedString = String.fromCharCode.apply(null, uintArray);\n  let decodedString = decodeURIComponent(escape(encodedString));\n  return decodedString;\n}\n\nfunction stringToUint8Array(str) {\n  var buf = new Uint8Array(str.length);\n  for (var i=0, strLen=str.length; i < strLen; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction equal(typedArray1, typedArray2) {\n  if (typedArray1.length !== typedArray2.length) {\n    return false;\n  }\n  for (let i = 0; i < typedArray1.length; i++) {\n    if (typedArray1[i] !== typedArray2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction TypedArrayList() {\n  this.typedArrays = [];\n  this.startIndexes = [];\n  this.length = 0;\n}\n\nTypedArrayList.prototype.add = function(typedArray) {\n  let typedArrayTypes = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array];\n\n  let matchingTypedArrayTypes = typedArrayTypes.filter(typedArrayType => typedArray instanceof typedArrayType);\n  if (matchingTypedArrayTypes.length < 1) {\n    throw Error('Given ' + typeof typedArray + ' when expected a TypedArray');\n  }\n\n  let startIndex;\n  if (this.typedArrays.length === 0) {\n    startIndex = 0;\n  }\n  else {\n    let lastIndex = this.startIndexes.length - 1;\n    let lastStartIndex = this.startIndexes[lastIndex];\n    let lastLength = this.typedArrays[lastIndex].length;\n    startIndex = lastStartIndex + lastLength;\n  }\n\n  this.startIndexes.push(startIndex);\n  this.typedArrays.push(typedArray);\n  this.length += startIndex + typedArray.length;\n};\n\nTypedArrayList.prototype.get = function(index) {\n  let listIndex = getIndex(this.startIndexes, index);\n  let typedArray = index - this.startIndexes[listIndex];\n  return this.typedArrays[listIndex][typedArray];\n};\n\nTypedArrayList.prototype.set = function(index, value) {\n  if (typeof index !== 'number' || isNaN(index)) {\n    throw new Error('Given non-number index: ' + index);\n  }\n  //console.log(index);\n\n  let listIndex = getIndex(this.startIndexes, index);\n  let typedArrayIndex = index - this.startIndexes[listIndex];\n  this.typedArrays[listIndex][typedArrayIndex] = value;\n};\n\nfunction getIndex(arr, element) {\n  // Performance optimization for most common case\n  if (arr.length === 2) {\n    return element < arr[1] ? 0 : 1;\n  }\n\n  let low = 0;\n  let high = arr.length - 1;\n\n  while (low < high) {\n    let mid = Math.floor((low + high) / 2);\n\n    if (arr[mid] === element) {\n      return mid;\n    }\n    else if (arr[mid] < element) {\n      low = mid + 1;\n    }\n    else {\n      high = mid - 1;\n    }\n  }\n  if (arr[high] > element) {\n    return high - 1;\n  }\n  else {\n    return high;\n  }\n}\n\nmodule.exports = {\n  uint8ArrayToString,\n  stringToUint8Array,\n  equal,\n  TypedArrayList\n};\n\n\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/typed_array_util.js?");

/***/ }),

/***/ "./node_modules/@ably/vcdiff-decoder/lib/vcdiff.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/vcdiff.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst errors = __webpack_require__(/*! ./errors */ \"./node_modules/@ably/vcdiff-decoder/lib/errors.js\");\nconst TypedArray = __webpack_require__(/*! ./typed_array_util */ \"./node_modules/@ably/vcdiff-decoder/lib/typed_array_util.js\");\nconst deserializeInteger = __webpack_require__(/*! ./deserialize/integer */ \"./node_modules/@ably/vcdiff-decoder/lib/deserialize/integer.js\");\nconst deserializeDelta = __webpack_require__(/*! ./deserialize/delta */ \"./node_modules/@ably/vcdiff-decoder/lib/deserialize/delta.js\");\nconst NearCache = __webpack_require__(/*! ./address_caches/near */ \"./node_modules/@ably/vcdiff-decoder/lib/address_caches/near.js\");\nconst SameCache = __webpack_require__(/*! ./address_caches/same */ \"./node_modules/@ably/vcdiff-decoder/lib/address_caches/same.js\");\n\n/**\n *\n * @param delta {Uint8Array}\n * @param source {Uint8Array}\n * @constructor\n */\nfunction VCDiff(delta, source) {\n  this.delta = delta;\n  this.position = 0;\n  this.source = source;\n  this.targetWindows = new TypedArray.TypedArrayList();\n}\n\nVCDiff.prototype.decode = function() {\n  this._consumeHeader();\n  while (this._consumeWindow()) {}\n\n  let targetLength = this.targetWindows.typedArrays.reduce((sum, uint8Array) => uint8Array.length + sum, 0);\n  let target = new Uint8Array(targetLength);\n  let position = 0;\n\n  // concat all uint8arrays\n  for (let arrayNum = 0; arrayNum < this.targetWindows.typedArrays.length; arrayNum++) {\n    let array = this.targetWindows.typedArrays[arrayNum];\n    let length = array.length;\n    target.set(array, position);\n    position += length;\n  }\n\n  return target;\n};\n\nVCDiff.prototype._consumeHeader = function() {\n\n  let hasVCDiffHeader = this.delta[0] === 214 && // V\n      this.delta[1] === 195 && // C\n      this.delta[2] === 196 && // D\n      this.delta[3] === 0; // \\0\n\n  if (!hasVCDiffHeader) {\n    throw new errors.InvalidDelta('first 3 bytes not VCD');\n  }\n\n  let hdrIndicator = this.delta[4];\n  // extract least significant bit\n  let vcdDecompress = 1 & hdrIndicator;\n  // extract second least significant bit\n  let vcdCodetable = 1 & (hdrIndicator >> 1);\n\n  // verify not using Hdr_Indicator\n  if (vcdDecompress || vcdCodetable) {\n    throw new errors.NotImplemented(\n      'non-zero Hdr_Indicator (VCD_DECOMPRESS or VCD_CODETABLE bit is set)'\n    );\n  }\n\n  this.position += 5;\n};\n\nVCDiff.prototype._consumeWindow = function() {\n  let winIndicator = this.delta[this.position++];\n\n  // extract least significant bit\n  let vcdSource = 1 & winIndicator;\n  // extract second least significant bit\n  let vcdTarget = 1 & (winIndicator >> 1);\n\n  if (vcdSource && vcdTarget) {\n    throw new errors.InvalidDelta(\n      'VCD_SOURCE and VCD_TARGET cannot both be set in Win_Indicator'\n    )\n  }\n  else if (vcdSource) {\n    let sourceSegmentLength, sourceSegmentPosition, deltaLength;\n    ({ value: sourceSegmentLength, position: this.position } = deserializeInteger(this.delta, this.position));\n    ({ value: sourceSegmentPosition, position: this.position } = deserializeInteger(this.delta, this.position));\n    ({ value: deltaLength, position: this.position } = deserializeInteger(this.delta, this.position));\n\n    let sourceSegment = this.source.slice(sourceSegmentPosition, sourceSegmentPosition + sourceSegmentLength);\n    this._buildTargetWindow(this.position, sourceSegment);\n    this.position += deltaLength;\n  }\n  else if (vcdTarget) {\n    throw new errors.NotImplemented(\n      'non-zero VCD_TARGET in Win_Indicator'\n    )\n  }\n  else {\n    let deltaLength;\n    ({ value: deltaLength, position: this.position } = deserializeInteger(this.delta, this.position));\n\n    this._buildTargetWindow(this.position);\n    this.position += deltaLength;\n  }\n\n  return this.position < this.delta.length;\n};\n\n// first integer is target window length\nVCDiff.prototype._buildTargetWindow = function(position, sourceSegment) {\n  let window = deserializeDelta(this.delta, position);\n\n  let T = new Uint8Array(window.targetWindowLength);\n\n  let U = new TypedArray.TypedArrayList();\n  let uTargetPosition = 0;\n  if (sourceSegment) {\n    U.add(sourceSegment);\n    uTargetPosition = sourceSegment.length;\n  }\n  U.add(T);\n\n  let targetPosition = this.source.length;\n  let dataPosition = 0;\n\n  let delta = new Delta(U, uTargetPosition, window.data, window.addresses);\n  window.instructions.forEach(instruction => {\n    instruction.execute(delta);\n  });\n\n  this.targetWindows.add(T);\n};\n\nfunction Delta(U, UTargetPosition, data, addresses) {\n  this.U = U;\n  this.UTargetPosition = UTargetPosition;\n  this.data = data;\n  this.dataPosition = 0;\n  this.addresses = addresses;\n  this.addressesPosition = 0;\n  this.nearCache = new NearCache(4);\n  this.sameCache = new SameCache(3);\n}\n\nDelta.prototype.getNextAddressInteger = function() {\n  let value;\n  // get next address and increase the address position for the next address\n  ({value, position: this.addressesPosition } = deserializeInteger(this.addresses, this.addressesPosition));\n  return value;\n};\n\nDelta.prototype.getNextAddressByte = function() {\n  // get next address and increase the address position for the next address\n  let value = this.addresses[this.addressesPosition++];\n  return value;\n};\n\nmodule.exports = VCDiff;\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/vcdiff.js?");

/***/ }),

/***/ "./node_modules/@ably/vcdiff-decoder/lib/vcdiff_decoder.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ably/vcdiff-decoder/lib/vcdiff_decoder.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst VCDiff = __webpack_require__(/*! ./vcdiff */ \"./node_modules/@ably/vcdiff-decoder/lib/vcdiff.js\");\n\n/**\n * Vcdiff decode, applying delta to source and returning the result.\n * \n * @param delta {Uint8Array} The Vcdiff format diff/patch to apply to source.\n * @param source {Uint8Array} The source to apply the delta diff/patch to.\n * @returns {Uint8Array} The result of applying delta to source.\n */\nfunction decode(delta, source) {\n  let vcdiff = new VCDiff(delta, source);\n  return vcdiff.decode();\n}\n\nmodule.exports = {\n  decode\n};\n\n\n//# sourceURL=webpack://sr-archive-lb/./node_modules/@ably/vcdiff-decoder/lib/vcdiff_decoder.js?");

/***/ })

}]);